//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export type ParticipationDtoResponse =
  | ParticipationStandardDtoResponse
  | ParticipationExtraDtoResponse
  | ParticipationSpecialDtoResponse;

export namespace ParticipationDtoResponse {
  export function fromJS(item: any): ParticipationDtoResponse {
    switch(item.type) {
      case 0: return ParticipationStandardDtoResponse.fromJS(item);
      case 1: return ParticipationExtraDtoResponse.fromJS(item);
      case 2: return ParticipationSpecialDtoResponse.fromJS(item);
      default: throw new Error('Unknown participation type ' + item.type);
    }
  }
}
export type MinigameDtoResponse =
  | MinigameResultDtoResponse
  | MinigameMatchDtoResponse
  | MinigameScoresDtoResponse
  | MinigamePlayersDtoResponse;

export namespace MinigameDtoResponse {
  export function fromJS(item: any): MinigameDtoResponse {
    switch(item.type) {
      case 1: return MinigameResultDtoResponse.fromJS(item);
      case 2: return MinigameMatchDtoResponse.fromJS(item);
      case 3: return MinigameScoresDtoResponse.fromJS(item);
      case 4: return MinigamePlayersDtoResponse.fromJS(item);
      default: throw new Error('Unknown minigame type ' + item.type);
    }
  }
}


export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IService {
    /**
     * @return OK
     */
    guest(): Observable<LoginResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: AuthDto | undefined): Observable<LoginResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthDto | undefined): Observable<LoginResponseDto>;
    register2(body: AuthDto | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    refresh(body: RefreshRequestDto | undefined): Observable<LoginResponseDto>;
    /**
     * @param body (optional) 
     * @return Created
     */
    competitionsPOST(body: CompetitionDto | undefined): Observable<CompetitionDtoResponse>;
    /**
     * @return OK
     */
    competitionsAll(): Observable<CompetitionDtoResponse[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    competitionsPUT(id: number, body: CompetitionDto | undefined): Observable<CompetitionDtoResponse>;
    /**
     * @return OK
     */
    competitionsGET(id: number): Observable<CompetitionDtoResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    standard(seasonId: number, body: ParticipationStandardDto | undefined): Observable<ParticipationStandardDtoResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    special(seasonId: number, body: ParticipationSpecialDto | undefined): Observable<ParticipationSpecialDtoResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    extra(seasonId: number, body: ParticipationExtraDto | undefined): Observable<ParticipationExtraDtoResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    play(seasonId: number, participationId: number, body: CreateUserParticipationDto | undefined): Observable<UserParticipationResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    resolve(seasonId: number, participationId: number, body: ParticipationResultDto[] | undefined):Observable<MinigameDtoResponse[]>;
    /**
     * @return OK
     */
    participationsAll(seasonId: number):Observable<ParticipationDtoResponse[]>;
    /**
     * @return OK
     */
    participations(seasonId: number, participationId: number):Observable<ParticipationDtoResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    playersPOST(teamId: number, body: PlayerDto | undefined): Observable<PlayerDtoResponse>;
    /**
     * @return OK
     */
    playersAll(teamId: number): Observable<PlayerDtoResponse[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    playersPUT(playerId: number, teamId: string, body: PlayerDto | undefined): Observable<PlayerDtoResponse>;
    /**
     * @return OK
     */
    playersGET(playerId: number, teamId: string): Observable<PlayerDtoResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    seasonsPOST(competitionId: number, body: SeasonDto | undefined): Observable<SeasonDtoResponse>;
    /**
     * @return OK
     */
    seasonsAll(competitionId: number): Observable<SeasonDtoResponse[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    seasonsPUT(seasonId: number, competitionId: string, body: SeasonDto | undefined): Observable<SeasonDtoResponse>;
    /**
     * @return OK
     */
    seasonsGET(seasonId: number, competitionId: string): Observable<SeasonDtoResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    teamsPOST(seasonId: number, body: TeamDto | undefined): Observable<TeamDtoResponse>;
    /**
     * @return OK
     */
    teamsAll(seasonId: number): Observable<TeamDtoResponse[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    teamsPUT(teamId: number, seasonId: string, body: TeamDto | undefined): Observable<TeamDtoResponse>;
    /**
     * @return OK
     */
    teamsGET(teamId: number, seasonId: string): Observable<TeamDtoResponse>;
}

@Injectable()
export class Service implements IService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    guest(): Observable<LoginResponseDto> {
        let url_ = this.baseUrl + "/api/Auth/guest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGuest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGuest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDto>;
        }));
    }

    protected processGuest(response: HttpResponseBase): Observable<LoginResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: AuthDto | undefined): Observable<LoginResponseDto> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDto>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<LoginResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthDto | undefined): Observable<LoginResponseDto> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDto>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseDto>(null as any);
    }

    register2(body: AuthDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/admin/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    refresh(body: RefreshRequestDto | undefined): Observable<LoginResponseDto> {
        let url_ = this.baseUrl + "/api/Auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDto>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<LoginResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    competitionsPOST(body: CompetitionDto | undefined): Observable<CompetitionDtoResponse> {
        let url_ = this.baseUrl + "/api/Competitions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompetitionsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompetitionsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompetitionDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompetitionDtoResponse>;
        }));
    }

    protected processCompetitionsPOST(response: HttpResponseBase): Observable<CompetitionDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CompetitionDtoResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompetitionDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    competitionsAll(): Observable<CompetitionDtoResponse[]> {
        let url_ = this.baseUrl + "/api/Competitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompetitionsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompetitionsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompetitionDtoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompetitionDtoResponse[]>;
        }));
    }

    protected processCompetitionsAll(response: HttpResponseBase): Observable<CompetitionDtoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompetitionDtoResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    competitionsPUT(id: number, body: CompetitionDto | undefined): Observable<CompetitionDtoResponse> {
        let url_ = this.baseUrl + "/api/Competitions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompetitionsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompetitionsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompetitionDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompetitionDtoResponse>;
        }));
    }

    protected processCompetitionsPUT(response: HttpResponseBase): Observable<CompetitionDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompetitionDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompetitionDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    competitionsGET(id: number): Observable<CompetitionDtoResponse> {
        let url_ = this.baseUrl + "/api/Competitions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompetitionsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompetitionsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompetitionDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompetitionDtoResponse>;
        }));
    }

    protected processCompetitionsGET(response: HttpResponseBase): Observable<CompetitionDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompetitionDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompetitionDtoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    standard(seasonId: number, body: ParticipationStandardDto | undefined): Observable<ParticipationStandardDtoResponse> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/participations/standard";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStandard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStandard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationStandardDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationStandardDtoResponse>;
        }));
    }

    protected processStandard(response: HttpResponseBase): Observable<ParticipationStandardDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ParticipationStandardDtoResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipationStandardDtoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    special(seasonId: number, body: ParticipationSpecialDto | undefined): Observable<ParticipationSpecialDtoResponse> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/participations/special";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationSpecialDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationSpecialDtoResponse>;
        }));
    }

    protected processSpecial(response: HttpResponseBase): Observable<ParticipationSpecialDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ParticipationSpecialDtoResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipationSpecialDtoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    extra(seasonId: number, body: ParticipationExtraDto | undefined): Observable<ParticipationExtraDtoResponse> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/participations/extra";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtra(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationExtraDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationExtraDtoResponse>;
        }));
    }

    protected processExtra(response: HttpResponseBase): Observable<ParticipationExtraDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ParticipationExtraDtoResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipationExtraDtoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    play(seasonId: number, participationId: number, body: CreateUserParticipationDto | undefined): Observable<UserParticipationResponseDto> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/participations/{participationId}/play";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        if (participationId === undefined || participationId === null)
            throw new Error("The parameter 'participationId' must be defined.");
        url_ = url_.replace("{participationId}", encodeURIComponent("" + participationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserParticipationResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserParticipationResponseDto>;
        }));
    }

    protected processPlay(response: HttpResponseBase): Observable<UserParticipationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserParticipationResponseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserParticipationResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resolve(seasonId: number, participationId: number, body: ParticipationResultDto[] | undefined):Observable<MinigameDtoResponse[]> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/participations/{participationId}/resolve";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        if (participationId === undefined || participationId === null)
            throw new Error("The parameter 'participationId' must be defined.");
        url_ = url_.replace("{participationId}", encodeURIComponent("" + participationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolve(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MinigameResultDtoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MinigameResultDtoResponse[]>;
        }));
    }

    protected processResolve(response: HttpResponseBase):Observable<MinigameDtoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MinigameDtoResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }

    }

    /**
     * @return OK
     */
    participationsAll(seasonId: number):Observable<ParticipationDtoResponse[]> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/participations";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipationsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipationsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationStandardDtoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationStandardDtoResponse[]>;
        }));
    }

    protected processParticipationsAll(response: HttpResponseBase):Observable<ParticipationDtoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParticipationDtoResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }

    }

    /**
     * @return OK
     */
    participations(seasonId: number, participationId: number):Observable<ParticipationDtoResponse> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/participations/{participationId}";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        if (participationId === undefined || participationId === null)
            throw new Error("The parameter 'participationId' must be defined.");
        url_ = url_.replace("{participationId}", encodeURIComponent("" + participationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipationStandardDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipationStandardDtoResponse>;
        }));
    }

    protected processParticipations(response: HttpResponseBase):Observable<ParticipationDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipationDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipationStandardDtoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    playersPOST(teamId: number, body: PlayerDto | undefined): Observable<PlayerDtoResponse> {
        let url_ = this.baseUrl + "/api/teams/{teamId}/players";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlayersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlayersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerDtoResponse>;
        }));
    }

    protected processPlayersPOST(response: HttpResponseBase): Observable<PlayerDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PlayerDtoResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlayerDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    playersAll(teamId: number): Observable<PlayerDtoResponse[]> {
        let url_ = this.baseUrl + "/api/teams/{teamId}/players";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlayersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlayersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerDtoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerDtoResponse[]>;
        }));
    }

    protected processPlayersAll(response: HttpResponseBase): Observable<PlayerDtoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlayerDtoResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    playersPUT(playerId: number, teamId: string, body: PlayerDto | undefined): Observable<PlayerDtoResponse> {
        let url_ = this.baseUrl + "/api/teams/{teamId}/players/{playerId}";
        if (playerId === undefined || playerId === null)
            throw new Error("The parameter 'playerId' must be defined.");
        url_ = url_.replace("{playerId}", encodeURIComponent("" + playerId));
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlayersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlayersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerDtoResponse>;
        }));
    }

    protected processPlayersPUT(response: HttpResponseBase): Observable<PlayerDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlayerDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    playersGET(playerId: number, teamId: string): Observable<PlayerDtoResponse> {
        let url_ = this.baseUrl + "/api/teams/{teamId}/players/{playerId}";
        if (playerId === undefined || playerId === null)
            throw new Error("The parameter 'playerId' must be defined.");
        url_ = url_.replace("{playerId}", encodeURIComponent("" + playerId));
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlayersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlayersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerDtoResponse>;
        }));
    }

    protected processPlayersGET(response: HttpResponseBase): Observable<PlayerDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlayerDtoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    seasonsPOST(competitionId: number, body: SeasonDto | undefined): Observable<SeasonDtoResponse> {
        let url_ = this.baseUrl + "/api/competitions/{competitionId}/seasons";
        if (competitionId === undefined || competitionId === null)
            throw new Error("The parameter 'competitionId' must be defined.");
        url_ = url_.replace("{competitionId}", encodeURIComponent("" + competitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeasonsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeasonsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeasonDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeasonDtoResponse>;
        }));
    }

    protected processSeasonsPOST(response: HttpResponseBase): Observable<SeasonDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SeasonDtoResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SeasonDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    seasonsAll(competitionId: number): Observable<SeasonDtoResponse[]> {
        let url_ = this.baseUrl + "/api/competitions/{competitionId}/seasons";
        if (competitionId === undefined || competitionId === null)
            throw new Error("The parameter 'competitionId' must be defined.");
        url_ = url_.replace("{competitionId}", encodeURIComponent("" + competitionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeasonsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeasonsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeasonDtoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeasonDtoResponse[]>;
        }));
    }

    protected processSeasonsAll(response: HttpResponseBase): Observable<SeasonDtoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SeasonDtoResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    seasonsPUT(seasonId: number, competitionId: string, body: SeasonDto | undefined): Observable<SeasonDtoResponse> {
        let url_ = this.baseUrl + "/api/competitions/{competitionId}/seasons/{seasonId}";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        if (competitionId === undefined || competitionId === null)
            throw new Error("The parameter 'competitionId' must be defined.");
        url_ = url_.replace("{competitionId}", encodeURIComponent("" + competitionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeasonsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeasonsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeasonDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeasonDtoResponse>;
        }));
    }

    protected processSeasonsPUT(response: HttpResponseBase): Observable<SeasonDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeasonDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SeasonDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    seasonsGET(seasonId: number, competitionId: string): Observable<SeasonDtoResponse> {
        let url_ = this.baseUrl + "/api/competitions/{competitionId}/seasons/{seasonId}";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        if (competitionId === undefined || competitionId === null)
            throw new Error("The parameter 'competitionId' must be defined.");
        url_ = url_.replace("{competitionId}", encodeURIComponent("" + competitionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeasonsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeasonsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SeasonDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SeasonDtoResponse>;
        }));
    }

    protected processSeasonsGET(response: HttpResponseBase): Observable<SeasonDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeasonDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SeasonDtoResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    teamsPOST(seasonId: number, body: TeamDto | undefined): Observable<TeamDtoResponse> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/teams";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeamsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeamsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamDtoResponse>;
        }));
    }

    protected processTeamsPOST(response: HttpResponseBase): Observable<TeamDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TeamDtoResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeamDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    teamsAll(seasonId: number): Observable<TeamDtoResponse[]> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/teams";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeamsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeamsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamDtoResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamDtoResponse[]>;
        }));
    }

    protected processTeamsAll(response: HttpResponseBase): Observable<TeamDtoResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamDtoResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    teamsPUT(teamId: number, seasonId: string, body: TeamDto | undefined): Observable<TeamDtoResponse> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeamsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeamsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamDtoResponse>;
        }));
    }

    protected processTeamsPUT(response: HttpResponseBase): Observable<TeamDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeamDtoResponse>(null as any);
    }

    /**
     * @return OK
     */
    teamsGET(teamId: number, seasonId: string): Observable<TeamDtoResponse> {
        let url_ = this.baseUrl + "/api/seasons/{seasonId}/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeamsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeamsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamDtoResponse>;
        }));
    }

    protected processTeamsGET(response: HttpResponseBase): Observable<TeamDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeamDtoResponse>(null as any);
    }
}

export class AuthDto implements IAuthDto {
    email!: string;
    password!: string;

    constructor(data?: IAuthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthDto {
    email: string;
    password: string;
}

export class CompetitionDto implements ICompetitionDto {
    name!: string;
    type?: CompetitionType;
    format?: CompetitionFormat;

    constructor(data?: ICompetitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.format = _data["format"];
        }
    }

    static fromJS(data: any): CompetitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompetitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["format"] = this.format;
        return data;
    }
}

export interface ICompetitionDto {
    name: string;
    type?: CompetitionType;
    format?: CompetitionFormat;
}

export class CompetitionDtoResponse implements ICompetitionDtoResponse {
    name!: string;
    type?: CompetitionType;
    format?: CompetitionFormat;
    id?: number;
    seasons?: SeasonDtoResponse[] | undefined;

    constructor(data?: ICompetitionDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.format = _data["format"];
            this.id = _data["id"];
            if (Array.isArray(_data["seasons"])) {
                this.seasons = [] as any;
                for (let item of _data["seasons"])
                    this.seasons!.push(SeasonDtoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompetitionDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompetitionDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["format"] = this.format;
        data["id"] = this.id;
        if (Array.isArray(this.seasons)) {
            data["seasons"] = [];
            for (let item of this.seasons)
                data["seasons"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICompetitionDtoResponse {
    name: string;
    type?: CompetitionType;
    format?: CompetitionFormat;
    id?: number;
    seasons?: SeasonDtoResponse[] | undefined;
}

export enum CompetitionFormat {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum CompetitionType {
    _0 = 0,
    _1 = 1,
}

export class CreateUserParticipationDto implements ICreateUserParticipationDto {
    groups?: UserPlayGroupDto[] | undefined;

    constructor(data?: ICreateUserParticipationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(UserPlayGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUserParticipationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserParticipationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICreateUserParticipationDto {
    groups?: UserPlayGroupDto[] | undefined;
}

export class IMinigameDtoResponse implements IIMinigameDtoResponse {
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;

    constructor(data?: IIMinigameDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.isResolved = _data["isResolved"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): IMinigameDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IMinigameDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["isResolved"] = this.isResolved;
        data["score"] = this.score;
        return data;
    }
}

export interface IIMinigameDtoResponse {
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;
}

export class IParticipationDtoResponse implements IIParticipationDtoResponse {
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;

    constructor(data?: IIParticipationDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.budget = _data["budget"];
            this.hasPlayed = _data["hasPlayed"];
            this.score = _data["score"];
            this.competition = _data["competition"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): IParticipationDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IParticipationDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["budget"] = this.budget;
        data["hasPlayed"] = this.hasPlayed;
        data["score"] = this.score;
        data["competition"] = this.competition;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IIParticipationDtoResponse {
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;
}

export class LoginResponseDto implements ILoginResponseDto {
    token?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ILoginResponseDto {
    token?: string | undefined;
    refreshToken?: string | undefined;
}

export enum MiniGameType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class MinigameGroupMatch2ADto implements IMinigameGroupMatch2ADto {
    minigameScores!: MinigameScoresDto;
    minigamePlayers!: MinigamePlayersDto;
    homeTeamId!: number;
    visitingTeamId!: number;

    constructor(data?: IMinigameGroupMatch2ADto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameScores = new MinigameScoresDto();
            this.minigamePlayers = new MinigamePlayersDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameScores = _data["minigameScores"] ? MinigameScoresDto.fromJS(_data["minigameScores"]) : new MinigameScoresDto();
            this.minigamePlayers = _data["minigamePlayers"] ? MinigamePlayersDto.fromJS(_data["minigamePlayers"]) : new MinigamePlayersDto();
            this.homeTeamId = _data["homeTeamId"];
            this.visitingTeamId = _data["visitingTeamId"];
        }
    }

    static fromJS(data: any): MinigameGroupMatch2ADto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMatch2ADto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameScores"] = this.minigameScores ? this.minigameScores.toJSON() : <any>undefined;
        data["minigamePlayers"] = this.minigamePlayers ? this.minigamePlayers.toJSON() : <any>undefined;
        data["homeTeamId"] = this.homeTeamId;
        data["visitingTeamId"] = this.visitingTeamId;
        return data;
    }
}

export interface IMinigameGroupMatch2ADto {
    minigameScores: MinigameScoresDto;
    minigamePlayers: MinigamePlayersDto;
    homeTeamId: number;
    visitingTeamId: number;
}

export class MinigameGroupMatch2ADtoResponse implements IMinigameGroupMatch2ADtoResponse {
    minigameScores!: MinigameScoresDtoResponse;
    minigamePlayers!: MinigamePlayersDtoResponse;
    homeTeamId!: number;
    visitingTeamId!: number;
    id?: number;
    score?: number | undefined;
    homeTeamName?: string | undefined;
    visitingTeamName?: string | undefined;

    constructor(data?: IMinigameGroupMatch2ADtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameScores = new MinigameScoresDtoResponse();
            this.minigamePlayers = new MinigamePlayersDtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameScores = _data["minigameScores"] ? MinigameScoresDtoResponse.fromJS(_data["minigameScores"]) : new MinigameScoresDtoResponse();
            this.minigamePlayers = _data["minigamePlayers"] ? MinigamePlayersDtoResponse.fromJS(_data["minigamePlayers"]) : new MinigamePlayersDtoResponse();
            this.homeTeamId = _data["homeTeamId"];
            this.visitingTeamId = _data["visitingTeamId"];
            this.id = _data["id"];
            this.score = _data["score"];
            this.homeTeamName = _data["homeTeamName"];
            this.visitingTeamName = _data["visitingTeamName"];
        }
    }

    static fromJS(data: any): MinigameGroupMatch2ADtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMatch2ADtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameScores"] = this.minigameScores ? this.minigameScores.toJSON() : <any>undefined;
        data["minigamePlayers"] = this.minigamePlayers ? this.minigamePlayers.toJSON() : <any>undefined;
        data["homeTeamId"] = this.homeTeamId;
        data["visitingTeamId"] = this.visitingTeamId;
        data["id"] = this.id;
        data["score"] = this.score;
        data["homeTeamName"] = this.homeTeamName;
        data["visitingTeamName"] = this.visitingTeamName;
        return data;
    }
}

export interface IMinigameGroupMatch2ADtoResponse {
    minigameScores: MinigameScoresDtoResponse;
    minigamePlayers: MinigamePlayersDtoResponse;
    homeTeamId: number;
    visitingTeamId: number;
    id?: number;
    score?: number | undefined;
    homeTeamName?: string | undefined;
    visitingTeamName?: string | undefined;
}

export class MinigameGroupMatch2BDto implements IMinigameGroupMatch2BDto {
    minigameMatch!: MinigameMatchDto;
    minigamePlayers!: MinigamePlayersDto;
    homeTeamId!: number;
    visitingTeamId!: number;

    constructor(data?: IMinigameGroupMatch2BDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameMatch = new MinigameMatchDto();
            this.minigamePlayers = new MinigamePlayersDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameMatch = _data["minigameMatch"] ? MinigameMatchDto.fromJS(_data["minigameMatch"]) : new MinigameMatchDto();
            this.minigamePlayers = _data["minigamePlayers"] ? MinigamePlayersDto.fromJS(_data["minigamePlayers"]) : new MinigamePlayersDto();
            this.homeTeamId = _data["homeTeamId"];
            this.visitingTeamId = _data["visitingTeamId"];
        }
    }

    static fromJS(data: any): MinigameGroupMatch2BDto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMatch2BDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameMatch"] = this.minigameMatch ? this.minigameMatch.toJSON() : <any>undefined;
        data["minigamePlayers"] = this.minigamePlayers ? this.minigamePlayers.toJSON() : <any>undefined;
        data["homeTeamId"] = this.homeTeamId;
        data["visitingTeamId"] = this.visitingTeamId;
        return data;
    }
}

export interface IMinigameGroupMatch2BDto {
    minigameMatch: MinigameMatchDto;
    minigamePlayers: MinigamePlayersDto;
    homeTeamId: number;
    visitingTeamId: number;
}

export class MinigameGroupMatch2BDtoResponse implements IMinigameGroupMatch2BDtoResponse {
    minigameMatch!: MinigameMatchDtoResponse;
    minigamePlayers!: MinigamePlayersDtoResponse;
    homeTeamId!: number;
    visitingTeamId!: number;
    id?: number;
    score?: number | undefined;
    homeTeamName?: string | undefined;
    visitingTeamName?: string | undefined;

    constructor(data?: IMinigameGroupMatch2BDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameMatch = new MinigameMatchDtoResponse();
            this.minigamePlayers = new MinigamePlayersDtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameMatch = _data["minigameMatch"] ? MinigameMatchDtoResponse.fromJS(_data["minigameMatch"]) : new MinigameMatchDtoResponse();
            this.minigamePlayers = _data["minigamePlayers"] ? MinigamePlayersDtoResponse.fromJS(_data["minigamePlayers"]) : new MinigamePlayersDtoResponse();
            this.homeTeamId = _data["homeTeamId"];
            this.visitingTeamId = _data["visitingTeamId"];
            this.id = _data["id"];
            this.score = _data["score"];
            this.homeTeamName = _data["homeTeamName"];
            this.visitingTeamName = _data["visitingTeamName"];
        }
    }

    static fromJS(data: any): MinigameGroupMatch2BDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMatch2BDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameMatch"] = this.minigameMatch ? this.minigameMatch.toJSON() : <any>undefined;
        data["minigamePlayers"] = this.minigamePlayers ? this.minigamePlayers.toJSON() : <any>undefined;
        data["homeTeamId"] = this.homeTeamId;
        data["visitingTeamId"] = this.visitingTeamId;
        data["id"] = this.id;
        data["score"] = this.score;
        data["homeTeamName"] = this.homeTeamName;
        data["visitingTeamName"] = this.visitingTeamName;
        return data;
    }
}

export interface IMinigameGroupMatch2BDtoResponse {
    minigameMatch: MinigameMatchDtoResponse;
    minigamePlayers: MinigamePlayersDtoResponse;
    homeTeamId: number;
    visitingTeamId: number;
    id?: number;
    score?: number | undefined;
    homeTeamName?: string | undefined;
    visitingTeamName?: string | undefined;
}

export class MinigameGroupMatch3Dto implements IMinigameGroupMatch3Dto {
    minigameScores!: MinigameScoresDto;
    minigamePlayers1!: MinigamePlayersDto;
    minigamePlayers2!: MinigamePlayersDto;
    homeTeamId!: number;
    visitingTeamId!: number;

    constructor(data?: IMinigameGroupMatch3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameScores = new MinigameScoresDto();
            this.minigamePlayers1 = new MinigamePlayersDto();
            this.minigamePlayers2 = new MinigamePlayersDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameScores = _data["minigameScores"] ? MinigameScoresDto.fromJS(_data["minigameScores"]) : new MinigameScoresDto();
            this.minigamePlayers1 = _data["minigamePlayers1"] ? MinigamePlayersDto.fromJS(_data["minigamePlayers1"]) : new MinigamePlayersDto();
            this.minigamePlayers2 = _data["minigamePlayers2"] ? MinigamePlayersDto.fromJS(_data["minigamePlayers2"]) : new MinigamePlayersDto();
            this.homeTeamId = _data["homeTeamId"];
            this.visitingTeamId = _data["visitingTeamId"];
        }
    }

    static fromJS(data: any): MinigameGroupMatch3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMatch3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameScores"] = this.minigameScores ? this.minigameScores.toJSON() : <any>undefined;
        data["minigamePlayers1"] = this.minigamePlayers1 ? this.minigamePlayers1.toJSON() : <any>undefined;
        data["minigamePlayers2"] = this.minigamePlayers2 ? this.minigamePlayers2.toJSON() : <any>undefined;
        data["homeTeamId"] = this.homeTeamId;
        data["visitingTeamId"] = this.visitingTeamId;
        return data;
    }
}

export interface IMinigameGroupMatch3Dto {
    minigameScores: MinigameScoresDto;
    minigamePlayers1: MinigamePlayersDto;
    minigamePlayers2: MinigamePlayersDto;
    homeTeamId: number;
    visitingTeamId: number;
}

export class MinigameGroupMatch3DtoResponse implements IMinigameGroupMatch3DtoResponse {
    minigameScores!: MinigameScoresDtoResponse;
    minigamePlayers1!: MinigamePlayersDtoResponse;
    minigamePlayers2!: MinigamePlayersDtoResponse;
    homeTeamId!: number;
    visitingTeamId!: number;
    id?: number;
    score?: number | undefined;
    homeTeamName?: string | undefined;
    visitingTeamName?: string | undefined;

    constructor(data?: IMinigameGroupMatch3DtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameScores = new MinigameScoresDtoResponse();
            this.minigamePlayers1 = new MinigamePlayersDtoResponse();
            this.minigamePlayers2 = new MinigamePlayersDtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameScores = _data["minigameScores"] ? MinigameScoresDtoResponse.fromJS(_data["minigameScores"]) : new MinigameScoresDtoResponse();
            this.minigamePlayers1 = _data["minigamePlayers1"] ? MinigamePlayersDtoResponse.fromJS(_data["minigamePlayers1"]) : new MinigamePlayersDtoResponse();
            this.minigamePlayers2 = _data["minigamePlayers2"] ? MinigamePlayersDtoResponse.fromJS(_data["minigamePlayers2"]) : new MinigamePlayersDtoResponse();
            this.homeTeamId = _data["homeTeamId"];
            this.visitingTeamId = _data["visitingTeamId"];
            this.id = _data["id"];
            this.score = _data["score"];
            this.homeTeamName = _data["homeTeamName"];
            this.visitingTeamName = _data["visitingTeamName"];
        }
    }

    static fromJS(data: any): MinigameGroupMatch3DtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMatch3DtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameScores"] = this.minigameScores ? this.minigameScores.toJSON() : <any>undefined;
        data["minigamePlayers1"] = this.minigamePlayers1 ? this.minigamePlayers1.toJSON() : <any>undefined;
        data["minigamePlayers2"] = this.minigamePlayers2 ? this.minigamePlayers2.toJSON() : <any>undefined;
        data["homeTeamId"] = this.homeTeamId;
        data["visitingTeamId"] = this.visitingTeamId;
        data["id"] = this.id;
        data["score"] = this.score;
        data["homeTeamName"] = this.homeTeamName;
        data["visitingTeamName"] = this.visitingTeamName;
        return data;
    }
}

export interface IMinigameGroupMatch3DtoResponse {
    minigameScores: MinigameScoresDtoResponse;
    minigamePlayers1: MinigamePlayersDtoResponse;
    minigamePlayers2: MinigamePlayersDtoResponse;
    homeTeamId: number;
    visitingTeamId: number;
    id?: number;
    score?: number | undefined;
    homeTeamName?: string | undefined;
    visitingTeamName?: string | undefined;
}

export class MinigameGroupMultiDto implements IMinigameGroupMultiDto {
    match1!: MinigameResultDto;
    match2!: MinigameResultDto;
    match3!: MinigameResultDto;

    constructor(data?: IMinigameGroupMultiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.match1 = new MinigameResultDto();
            this.match2 = new MinigameResultDto();
            this.match3 = new MinigameResultDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.match1 = _data["match1"] ? MinigameResultDto.fromJS(_data["match1"]) : new MinigameResultDto();
            this.match2 = _data["match2"] ? MinigameResultDto.fromJS(_data["match2"]) : new MinigameResultDto();
            this.match3 = _data["match3"] ? MinigameResultDto.fromJS(_data["match3"]) : new MinigameResultDto();
        }
    }

    static fromJS(data: any): MinigameGroupMultiDto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMultiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["match1"] = this.match1 ? this.match1.toJSON() : <any>undefined;
        data["match2"] = this.match2 ? this.match2.toJSON() : <any>undefined;
        data["match3"] = this.match3 ? this.match3.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMinigameGroupMultiDto {
    match1: MinigameResultDto;
    match2: MinigameResultDto;
    match3: MinigameResultDto;
}

export class MinigameGroupMultiDtoResponse implements IMinigameGroupMultiDtoResponse {
    match1!: MinigameResultDtoResponse;
    match2!: MinigameResultDtoResponse;
    match3!: MinigameResultDtoResponse;
    id?: number;
    score?: number | undefined;

    constructor(data?: IMinigameGroupMultiDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.match1 = new MinigameResultDtoResponse();
            this.match2 = new MinigameResultDtoResponse();
            this.match3 = new MinigameResultDtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.match1 = _data["match1"] ? MinigameResultDtoResponse.fromJS(_data["match1"]) : new MinigameResultDtoResponse();
            this.match2 = _data["match2"] ? MinigameResultDtoResponse.fromJS(_data["match2"]) : new MinigameResultDtoResponse();
            this.match3 = _data["match3"] ? MinigameResultDtoResponse.fromJS(_data["match3"]) : new MinigameResultDtoResponse();
            this.id = _data["id"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): MinigameGroupMultiDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameGroupMultiDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["match1"] = this.match1 ? this.match1.toJSON() : <any>undefined;
        data["match2"] = this.match2 ? this.match2.toJSON() : <any>undefined;
        data["match3"] = this.match3 ? this.match3.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["score"] = this.score;
        return data;
    }
}

export interface IMinigameGroupMultiDtoResponse {
    match1: MinigameResultDtoResponse;
    match2: MinigameResultDtoResponse;
    match3: MinigameResultDtoResponse;
    id?: number;
    score?: number | undefined;
}

export class MinigameMatchDto implements IMinigameMatchDto {
    options!: OptionIntervalDto[];
    miniGameMatchType!: MinigameMatchType;

    constructor(data?: IMinigameMatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionIntervalDto.fromJS(item));
            }
            this.miniGameMatchType = _data["miniGameMatchType"];
        }
    }

    static fromJS(data: any): MinigameMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : <any>undefined);
        }
        data["miniGameMatchType"] = this.miniGameMatchType;
        return data;
    }
}

export interface IMinigameMatchDto {
    options: OptionIntervalDto[];
    miniGameMatchType: MinigameMatchType;
}

export class MinigameMatchDtoResponse implements IMinigameMatchDtoResponse {
    options!: OptionIntervalDtoResponse[] | undefined;
    miniGameMatchType!: MinigameMatchType;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;

    constructor(data?: IMinigameMatchDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionIntervalDtoResponse.fromJS(item));
            }
            this.miniGameMatchType = _data["miniGameMatchType"];
            this.type = _data["type"];
            this.id = _data["id"];
            this.isResolved = _data["isResolved"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): MinigameMatchDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameMatchDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : <any>undefined);
        }
        data["miniGameMatchType"] = this.miniGameMatchType;
        data["type"] = this.type;
        data["id"] = this.id;
        data["isResolved"] = this.isResolved;
        data["score"] = this.score;
        return data;
    }
}

export interface IMinigameMatchDtoResponse {
    options: OptionIntervalDtoResponse[] | undefined;
    miniGameMatchType: MinigameMatchType;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;
}

export enum MinigameMatchType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class MinigamePlayersDto implements IMinigamePlayersDto {
    options!: OptionPlayerDto[];
    playersType!: MinigamePlayersType;

    constructor(data?: IMinigamePlayersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionPlayerDto.fromJS(item));
            }
            this.playersType = _data["playersType"];
        }
    }

    static fromJS(data: any): MinigamePlayersDto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigamePlayersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : <any>undefined);
        }
        data["playersType"] = this.playersType;
        return data;
    }
}

export interface IMinigamePlayersDto {
    options: OptionPlayerDto[];
    playersType: MinigamePlayersType;
}

export class MinigamePlayersDtoResponse implements IMinigamePlayersDtoResponse {
    options!: OptionPlayerDtoResponse[] | undefined;
    playersType?: MinigamePlayersType;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;

    constructor(data?: IMinigamePlayersDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionPlayerDtoResponse.fromJS(item));
            }
            this.playersType = _data["playersType"];
            this.type = _data["type"];
            this.id = _data["id"];
            this.isResolved = _data["isResolved"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): MinigamePlayersDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigamePlayersDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : <any>undefined);
        }
        data["playersType"] = this.playersType;
        data["type"] = this.type;
        data["id"] = this.id;
        data["isResolved"] = this.isResolved;
        data["score"] = this.score;
        return data;
    }
}

export interface IMinigamePlayersDtoResponse {
    options: OptionPlayerDtoResponse[] | undefined;
    playersType?: MinigamePlayersType;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;
}

export enum MinigamePlayersType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class MinigameResultDto implements IMinigameResultDto {
    draw!: OptionDto;
    homeVictory!: OptionTeamDto;
    visitingVictory!: OptionTeamDto;

    constructor(data?: IMinigameResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.draw = new OptionDto();
            this.homeVictory = new OptionTeamDto();
            this.visitingVictory = new OptionTeamDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"] ? OptionDto.fromJS(_data["draw"]) : new OptionDto();
            this.homeVictory = _data["homeVictory"] ? OptionTeamDto.fromJS(_data["homeVictory"]) : new OptionTeamDto();
            this.visitingVictory = _data["visitingVictory"] ? OptionTeamDto.fromJS(_data["visitingVictory"]) : new OptionTeamDto();
        }
    }

    static fromJS(data: any): MinigameResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw ? this.draw.toJSON() : <any>undefined;
        data["homeVictory"] = this.homeVictory ? this.homeVictory.toJSON() : <any>undefined;
        data["visitingVictory"] = this.visitingVictory ? this.visitingVictory.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMinigameResultDto {
    draw: OptionDto;
    homeVictory: OptionTeamDto;
    visitingVictory: OptionTeamDto;
}

export class MinigameResultDtoResponse implements IMinigameResultDtoResponse {
    draw!: OptionDtoResponse;
    homeVictory!: OptionTeamDtoResponse;
    visitingVictory!: OptionTeamDtoResponse;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;

    constructor(data?: IMinigameResultDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.draw = new OptionDtoResponse();
            this.homeVictory = new OptionTeamDtoResponse();
            this.visitingVictory = new OptionTeamDtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draw = _data["draw"] ? OptionDtoResponse.fromJS(_data["draw"]) : new OptionDtoResponse();
            this.homeVictory = _data["homeVictory"] ? OptionTeamDtoResponse.fromJS(_data["homeVictory"]) : new OptionTeamDtoResponse();
            this.visitingVictory = _data["visitingVictory"] ? OptionTeamDtoResponse.fromJS(_data["visitingVictory"]) : new OptionTeamDtoResponse();
            this.type = _data["type"];
            this.id = _data["id"];
            this.isResolved = _data["isResolved"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): MinigameResultDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameResultDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draw"] = this.draw ? this.draw.toJSON() : <any>undefined;
        data["homeVictory"] = this.homeVictory ? this.homeVictory.toJSON() : <any>undefined;
        data["visitingVictory"] = this.visitingVictory ? this.visitingVictory.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["id"] = this.id;
        data["isResolved"] = this.isResolved;
        data["score"] = this.score;
        return data;
    }
}

export interface IMinigameResultDtoResponse {
    draw: OptionDtoResponse;
    homeVictory: OptionTeamDtoResponse;
    visitingVictory: OptionTeamDtoResponse;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;
}

export class MinigameScoresDto implements IMinigameScoresDto {
    options!: OptionScoreDto[];

    constructor(data?: IMinigameScoresDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionScoreDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MinigameScoresDto {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameScoresDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IMinigameScoresDto {
    options: OptionScoreDto[];
}

export class MinigameScoresDtoResponse implements IMinigameScoresDtoResponse {
    options!: OptionScoreDtoResponse[] | undefined;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;

    constructor(data?: IMinigameScoresDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionScoreDtoResponse.fromJS(item));
            }
            this.type = _data["type"];
            this.id = _data["id"];
            this.isResolved = _data["isResolved"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): MinigameScoresDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MinigameScoresDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : <any>undefined);
        }
        data["type"] = this.type;
        data["id"] = this.id;
        data["isResolved"] = this.isResolved;
        data["score"] = this.score;
        return data;
    }
}

export interface IMinigameScoresDtoResponse {
    options: OptionScoreDtoResponse[] | undefined;
    type?: MiniGameType;
    id?: number;
    isResolved?: boolean;
    score?: number | undefined;
}

export class OptionDto implements IOptionDto {
    probability!: number;

    constructor(data?: IOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.probability = _data["probability"];
        }
    }

    static fromJS(data: any): OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["probability"] = this.probability;
        return data;
    }
}

export interface IOptionDto {
    probability: number;
}

export class OptionDtoResponse implements IOptionDtoResponse {
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;

    constructor(data?: IOptionDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.hasOccurred = _data["hasOccurred"];
            this.isPlayed = _data["isPlayed"];
        }
    }

    static fromJS(data: any): OptionDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["hasOccurred"] = this.hasOccurred;
        data["isPlayed"] = this.isPlayed;
        return data;
    }
}

export interface IOptionDtoResponse {
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;
}

export class OptionIntervalDto implements IOptionIntervalDto {
    probability!: number;
    min?: number | undefined;
    max?: number | undefined;

    constructor(data?: IOptionIntervalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.probability = _data["probability"];
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): OptionIntervalDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionIntervalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["probability"] = this.probability;
        data["min"] = this.min;
        data["max"] = this.max;
        return data;
    }
}

export interface IOptionIntervalDto {
    probability: number;
    min?: number | undefined;
    max?: number | undefined;
}

export class OptionIntervalDtoResponse implements IOptionIntervalDtoResponse {
    min?: number | undefined;
    max?: number | undefined;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;

    constructor(data?: IOptionIntervalDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.min = _data["min"];
            this.max = _data["max"];
            this.id = _data["id"];
            this.price = _data["price"];
            this.hasOccurred = _data["hasOccurred"];
            this.isPlayed = _data["isPlayed"];
        }
    }

    static fromJS(data: any): OptionIntervalDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OptionIntervalDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        data["id"] = this.id;
        data["price"] = this.price;
        data["hasOccurred"] = this.hasOccurred;
        data["isPlayed"] = this.isPlayed;
        return data;
    }
}

export interface IOptionIntervalDtoResponse {
    min?: number | undefined;
    max?: number | undefined;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;
}

export class OptionPlayerDto implements IOptionPlayerDto {
    probability!: number;
    playerId!: number;

    constructor(data?: IOptionPlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.probability = _data["probability"];
            this.playerId = _data["playerId"];
        }
    }

    static fromJS(data: any): OptionPlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionPlayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["probability"] = this.probability;
        data["playerId"] = this.playerId;
        return data;
    }
}

export interface IOptionPlayerDto {
    probability: number;
    playerId: number;
}

export class OptionPlayerDtoResponse implements IOptionPlayerDtoResponse {
    playerId!: number;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;
    playerName?: string | undefined;
    teamName?: string | undefined;

    constructor(data?: IOptionPlayerDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.id = _data["id"];
            this.price = _data["price"];
            this.hasOccurred = _data["hasOccurred"];
            this.isPlayed = _data["isPlayed"];
            this.playerName = _data["playerName"];
            this.teamName = _data["teamName"];
        }
    }

    static fromJS(data: any): OptionPlayerDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OptionPlayerDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["id"] = this.id;
        data["price"] = this.price;
        data["hasOccurred"] = this.hasOccurred;
        data["isPlayed"] = this.isPlayed;
        data["playerName"] = this.playerName;
        data["teamName"] = this.teamName;
        return data;
    }
}

export interface IOptionPlayerDtoResponse {
    playerId: number;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;
    playerName?: string | undefined;
    teamName?: string | undefined;
}

export class OptionScoreDto implements IOptionScoreDto {
    probability!: number;
    homeGoals!: number;
    awayGoals!: number;

    constructor(data?: IOptionScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.probability = _data["probability"];
            this.homeGoals = _data["homeGoals"];
            this.awayGoals = _data["awayGoals"];
        }
    }

    static fromJS(data: any): OptionScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["probability"] = this.probability;
        data["homeGoals"] = this.homeGoals;
        data["awayGoals"] = this.awayGoals;
        return data;
    }
}

export interface IOptionScoreDto {
    probability: number;
    homeGoals: number;
    awayGoals: number;
}

export class OptionScoreDtoResponse implements IOptionScoreDtoResponse {
    homeGoals!: number;
    awayGoals!: number;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;

    constructor(data?: IOptionScoreDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeGoals = _data["homeGoals"];
            this.awayGoals = _data["awayGoals"];
            this.id = _data["id"];
            this.price = _data["price"];
            this.hasOccurred = _data["hasOccurred"];
            this.isPlayed = _data["isPlayed"];
        }
    }

    static fromJS(data: any): OptionScoreDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OptionScoreDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeGoals"] = this.homeGoals;
        data["awayGoals"] = this.awayGoals;
        data["id"] = this.id;
        data["price"] = this.price;
        data["hasOccurred"] = this.hasOccurred;
        data["isPlayed"] = this.isPlayed;
        return data;
    }
}

export interface IOptionScoreDtoResponse {
    homeGoals: number;
    awayGoals: number;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;
}

export class OptionTeamDto implements IOptionTeamDto {
    probability!: number;
    teamId!: number;

    constructor(data?: IOptionTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.probability = _data["probability"];
            this.teamId = _data["teamId"];
        }
    }

    static fromJS(data: any): OptionTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["probability"] = this.probability;
        data["teamId"] = this.teamId;
        return data;
    }
}

export interface IOptionTeamDto {
    probability: number;
    teamId: number;
}

export class OptionTeamDtoResponse implements IOptionTeamDtoResponse {
    teamId!: number;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;
    teamName?: string | undefined;

    constructor(data?: IOptionTeamDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
            this.id = _data["id"];
            this.price = _data["price"];
            this.hasOccurred = _data["hasOccurred"];
            this.isPlayed = _data["isPlayed"];
            this.teamName = _data["teamName"];
        }
    }

    static fromJS(data: any): OptionTeamDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OptionTeamDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        data["id"] = this.id;
        data["price"] = this.price;
        data["hasOccurred"] = this.hasOccurred;
        data["isPlayed"] = this.isPlayed;
        data["teamName"] = this.teamName;
        return data;
    }
}

export interface IOptionTeamDtoResponse {
    teamId: number;
    id?: number;
    price?: number;
    hasOccurred?: boolean;
    isPlayed?: boolean | undefined;
    teamName?: string | undefined;
}

export class ParticipationExtraDto implements IParticipationExtraDto {
    date!: Date;
    round!: string;
    roundAbbreviation!: string;
    numberInRound!: number;
    minigameGroupMatch2A!: MinigameGroupMatch2ADto;
    minigameGroupMatch2B!: MinigameGroupMatch2BDto;

    constructor(data?: IParticipationExtraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameGroupMatch2A = new MinigameGroupMatch2ADto();
            this.minigameGroupMatch2B = new MinigameGroupMatch2BDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.round = _data["round"];
            this.roundAbbreviation = _data["roundAbbreviation"];
            this.numberInRound = _data["numberInRound"];
            this.minigameGroupMatch2A = _data["minigameGroupMatch2A"] ? MinigameGroupMatch2ADto.fromJS(_data["minigameGroupMatch2A"]) : new MinigameGroupMatch2ADto();
            this.minigameGroupMatch2B = _data["minigameGroupMatch2B"] ? MinigameGroupMatch2BDto.fromJS(_data["minigameGroupMatch2B"]) : new MinigameGroupMatch2BDto();
        }
    }

    static fromJS(data: any): ParticipationExtraDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationExtraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["round"] = this.round;
        data["roundAbbreviation"] = this.roundAbbreviation;
        data["numberInRound"] = this.numberInRound;
        data["minigameGroupMatch2A"] = this.minigameGroupMatch2A ? this.minigameGroupMatch2A.toJSON() : <any>undefined;
        data["minigameGroupMatch2B"] = this.minigameGroupMatch2B ? this.minigameGroupMatch2B.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipationExtraDto {
    date: Date;
    round: string;
    roundAbbreviation: string;
    numberInRound: number;
    minigameGroupMatch2A: MinigameGroupMatch2ADto;
    minigameGroupMatch2B: MinigameGroupMatch2BDto;
}

export class ParticipationExtraDtoResponse implements IParticipationExtraDtoResponse {
    date!: Date;
    round!: string;
    roundAbbreviation!: string;
    numberInRound!: number;
    minigameGroupMatch2A!: MinigameGroupMatch2ADtoResponse;
    minigameGroupMatch2B!: MinigameGroupMatch2BDtoResponse;
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;

    constructor(data?: IParticipationExtraDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameGroupMatch2A = new MinigameGroupMatch2ADtoResponse();
            this.minigameGroupMatch2B = new MinigameGroupMatch2BDtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.round = _data["round"];
            this.roundAbbreviation = _data["roundAbbreviation"];
            this.numberInRound = _data["numberInRound"];
            this.minigameGroupMatch2A = _data["minigameGroupMatch2A"] ? MinigameGroupMatch2ADtoResponse.fromJS(_data["minigameGroupMatch2A"]) : new MinigameGroupMatch2ADtoResponse();
            this.minigameGroupMatch2B = _data["minigameGroupMatch2B"] ? MinigameGroupMatch2BDtoResponse.fromJS(_data["minigameGroupMatch2B"]) : new MinigameGroupMatch2BDtoResponse();
            this.type = _data["type"];
            this.id = _data["id"];
            this.budget = _data["budget"];
            this.hasPlayed = _data["hasPlayed"];
            this.score = _data["score"];
            this.competition = _data["competition"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipationExtraDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationExtraDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["round"] = this.round;
        data["roundAbbreviation"] = this.roundAbbreviation;
        data["numberInRound"] = this.numberInRound;
        data["minigameGroupMatch2A"] = this.minigameGroupMatch2A ? this.minigameGroupMatch2A.toJSON() : <any>undefined;
        data["minigameGroupMatch2B"] = this.minigameGroupMatch2B ? this.minigameGroupMatch2B.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["id"] = this.id;
        data["budget"] = this.budget;
        data["hasPlayed"] = this.hasPlayed;
        data["score"] = this.score;
        data["competition"] = this.competition;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipationExtraDtoResponse {
    date: Date;
    round: string;
    roundAbbreviation: string;
    numberInRound: number;
    minigameGroupMatch2A: MinigameGroupMatch2ADtoResponse;
    minigameGroupMatch2B: MinigameGroupMatch2BDtoResponse;
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;
}

export class ParticipationResultDto implements IParticipationResultDto {
    minigameId!: number;
    ocurredOptions!: number[];

    constructor(data?: IParticipationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ocurredOptions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameId = _data["minigameId"];
            if (Array.isArray(_data["ocurredOptions"])) {
                this.ocurredOptions = [] as any;
                for (let item of _data["ocurredOptions"])
                    this.ocurredOptions!.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameId"] = this.minigameId;
        if (Array.isArray(this.ocurredOptions)) {
            data["ocurredOptions"] = [];
            for (let item of this.ocurredOptions)
                data["ocurredOptions"].push(item);
        }
        return data;
    }
}

export interface IParticipationResultDto {
    minigameId: number;
    ocurredOptions: number[];
}

export class ParticipationSpecialDto implements IParticipationSpecialDto {
    date!: Date;
    round!: string;
    roundAbbreviation!: string;
    numberInRound!: number;
    minigameGroupMatch2A!: MinigameGroupMatch2ADto;
    minigameGroupMatch2B!: MinigameGroupMatch2BDto;

    constructor(data?: IParticipationSpecialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameGroupMatch2A = new MinigameGroupMatch2ADto();
            this.minigameGroupMatch2B = new MinigameGroupMatch2BDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.round = _data["round"];
            this.roundAbbreviation = _data["roundAbbreviation"];
            this.numberInRound = _data["numberInRound"];
            this.minigameGroupMatch2A = _data["minigameGroupMatch2A"] ? MinigameGroupMatch2ADto.fromJS(_data["minigameGroupMatch2A"]) : new MinigameGroupMatch2ADto();
            this.minigameGroupMatch2B = _data["minigameGroupMatch2B"] ? MinigameGroupMatch2BDto.fromJS(_data["minigameGroupMatch2B"]) : new MinigameGroupMatch2BDto();
        }
    }

    static fromJS(data: any): ParticipationSpecialDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationSpecialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["round"] = this.round;
        data["roundAbbreviation"] = this.roundAbbreviation;
        data["numberInRound"] = this.numberInRound;
        data["minigameGroupMatch2A"] = this.minigameGroupMatch2A ? this.minigameGroupMatch2A.toJSON() : <any>undefined;
        data["minigameGroupMatch2B"] = this.minigameGroupMatch2B ? this.minigameGroupMatch2B.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipationSpecialDto {
    date: Date;
    round: string;
    roundAbbreviation: string;
    numberInRound: number;
    minigameGroupMatch2A: MinigameGroupMatch2ADto;
    minigameGroupMatch2B: MinigameGroupMatch2BDto;
}

export class ParticipationSpecialDtoResponse implements IParticipationSpecialDtoResponse {
    date!: Date;
    round!: string;
    roundAbbreviation!: string;
    numberInRound!: number;
    minigameGroupMatch2A!: MinigameGroupMatch2ADtoResponse;
    minigameGroupMatch2B!: MinigameGroupMatch2BDtoResponse;
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;

    constructor(data?: IParticipationSpecialDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameGroupMatch2A = new MinigameGroupMatch2ADtoResponse();
            this.minigameGroupMatch2B = new MinigameGroupMatch2BDtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.round = _data["round"];
            this.roundAbbreviation = _data["roundAbbreviation"];
            this.numberInRound = _data["numberInRound"];
            this.minigameGroupMatch2A = _data["minigameGroupMatch2A"] ? MinigameGroupMatch2ADtoResponse.fromJS(_data["minigameGroupMatch2A"]) : new MinigameGroupMatch2ADtoResponse();
            this.minigameGroupMatch2B = _data["minigameGroupMatch2B"] ? MinigameGroupMatch2BDtoResponse.fromJS(_data["minigameGroupMatch2B"]) : new MinigameGroupMatch2BDtoResponse();
            this.type = _data["type"];
            this.id = _data["id"];
            this.budget = _data["budget"];
            this.hasPlayed = _data["hasPlayed"];
            this.score = _data["score"];
            this.competition = _data["competition"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipationSpecialDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationSpecialDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["round"] = this.round;
        data["roundAbbreviation"] = this.roundAbbreviation;
        data["numberInRound"] = this.numberInRound;
        data["minigameGroupMatch2A"] = this.minigameGroupMatch2A ? this.minigameGroupMatch2A.toJSON() : <any>undefined;
        data["minigameGroupMatch2B"] = this.minigameGroupMatch2B ? this.minigameGroupMatch2B.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["id"] = this.id;
        data["budget"] = this.budget;
        data["hasPlayed"] = this.hasPlayed;
        data["score"] = this.score;
        data["competition"] = this.competition;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipationSpecialDtoResponse {
    date: Date;
    round: string;
    roundAbbreviation: string;
    numberInRound: number;
    minigameGroupMatch2A: MinigameGroupMatch2ADtoResponse;
    minigameGroupMatch2B: MinigameGroupMatch2BDtoResponse;
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;
}

export class ParticipationStandardDto implements IParticipationStandardDto {
    date!: Date;
    round!: string;
    roundAbbreviation!: string;
    numberInRound!: number;
    minigameGroupMulti!: MinigameGroupMultiDto;
    minigameGroupMatch3!: MinigameGroupMatch3Dto;

    constructor(data?: IParticipationStandardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameGroupMulti = new MinigameGroupMultiDto();
            this.minigameGroupMatch3 = new MinigameGroupMatch3Dto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.round = _data["round"];
            this.roundAbbreviation = _data["roundAbbreviation"];
            this.numberInRound = _data["numberInRound"];
            this.minigameGroupMulti = _data["minigameGroupMulti"] ? MinigameGroupMultiDto.fromJS(_data["minigameGroupMulti"]) : new MinigameGroupMultiDto();
            this.minigameGroupMatch3 = _data["minigameGroupMatch3"] ? MinigameGroupMatch3Dto.fromJS(_data["minigameGroupMatch3"]) : new MinigameGroupMatch3Dto();
        }
    }

    static fromJS(data: any): ParticipationStandardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationStandardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["round"] = this.round;
        data["roundAbbreviation"] = this.roundAbbreviation;
        data["numberInRound"] = this.numberInRound;
        data["minigameGroupMulti"] = this.minigameGroupMulti ? this.minigameGroupMulti.toJSON() : <any>undefined;
        data["minigameGroupMatch3"] = this.minigameGroupMatch3 ? this.minigameGroupMatch3.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipationStandardDto {
    date: Date;
    round: string;
    roundAbbreviation: string;
    numberInRound: number;
    minigameGroupMulti: MinigameGroupMultiDto;
    minigameGroupMatch3: MinigameGroupMatch3Dto;
}

export class ParticipationStandardDtoResponse implements IParticipationStandardDtoResponse {
    date!: Date;
    round!: string;
    roundAbbreviation!: string;
    numberInRound!: number;
    minigameGroupMulti!: MinigameGroupMultiDtoResponse;
    minigameGroupMatch3!: MinigameGroupMatch3DtoResponse;
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;

    constructor(data?: IParticipationStandardDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minigameGroupMulti = new MinigameGroupMultiDtoResponse();
            this.minigameGroupMatch3 = new MinigameGroupMatch3DtoResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.round = _data["round"];
            this.roundAbbreviation = _data["roundAbbreviation"];
            this.numberInRound = _data["numberInRound"];
            this.minigameGroupMulti = _data["minigameGroupMulti"] ? MinigameGroupMultiDtoResponse.fromJS(_data["minigameGroupMulti"]) : new MinigameGroupMultiDtoResponse();
            this.minigameGroupMatch3 = _data["minigameGroupMatch3"] ? MinigameGroupMatch3DtoResponse.fromJS(_data["minigameGroupMatch3"]) : new MinigameGroupMatch3DtoResponse();
            this.type = _data["type"];
            this.id = _data["id"];
            this.budget = _data["budget"];
            this.hasPlayed = _data["hasPlayed"];
            this.score = _data["score"];
            this.competition = _data["competition"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipationStandardDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipationStandardDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["round"] = this.round;
        data["roundAbbreviation"] = this.roundAbbreviation;
        data["numberInRound"] = this.numberInRound;
        data["minigameGroupMulti"] = this.minigameGroupMulti ? this.minigameGroupMulti.toJSON() : <any>undefined;
        data["minigameGroupMatch3"] = this.minigameGroupMatch3 ? this.minigameGroupMatch3.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["id"] = this.id;
        data["budget"] = this.budget;
        data["hasPlayed"] = this.hasPlayed;
        data["score"] = this.score;
        data["competition"] = this.competition;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipationStandardDtoResponse {
    date: Date;
    round: string;
    roundAbbreviation: string;
    numberInRound: number;
    minigameGroupMulti: MinigameGroupMultiDtoResponse;
    minigameGroupMatch3: MinigameGroupMatch3DtoResponse;
    type?: ParticipationType;
    id?: number;
    budget?: number;
    hasPlayed?: boolean;
    score?: number | undefined;
    competition?: string | undefined;
    lastUpdate?: Date | undefined;
}

export enum ParticipationType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class PlayerDto implements IPlayerDto {
    name!: string;

    constructor(data?: IPlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IPlayerDto {
    name: string;
}

export class PlayerDtoResponse implements IPlayerDtoResponse {
    name!: string;
    id?: number;

    constructor(data?: IPlayerDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlayerDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IPlayerDtoResponse {
    name: string;
    id?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RefreshRequestDto implements IRefreshRequestDto {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: IRefreshRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequestDto {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
}

export class SeasonDto implements ISeasonDto {
    year!: number;

    constructor(data?: ISeasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): SeasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        return data;
    }
}

export interface ISeasonDto {
    year: number;
}

export class SeasonDtoResponse implements ISeasonDtoResponse {
    year!: number;
    id?: number;

    constructor(data?: ISeasonDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SeasonDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["id"] = this.id;
        return data;
    }
}

export interface ISeasonDtoResponse {
    year: number;
    id?: number;
}

export class TeamDto implements ITeamDto {
    name!: string;
    abbreviation!: string;
    players?: PlayerDtoResponse[] | undefined;

    constructor(data?: ITeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(PlayerDtoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ITeamDto {
    name: string;
    abbreviation: string;
    players?: PlayerDtoResponse[] | undefined;
}

export class TeamDtoResponse implements ITeamDtoResponse {
    name!: string;
    abbreviation!: string;
    id?: number;
    players?: PlayerDtoResponse[] | undefined;

    constructor(data?: ITeamDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
            this.id = _data["id"];
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(PlayerDtoResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        data["id"] = this.id;
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ITeamDtoResponse {
    name: string;
    abbreviation: string;
    id?: number;
    players?: PlayerDtoResponse[] | undefined;
}

export class UserMinigameResponseDto implements IUserMinigameResponseDto {
    minigameId?: number;
    selectedOptionIds?: number[] | undefined;
    id?: number;

    constructor(data?: IUserMinigameResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameId = _data["minigameId"];
            if (Array.isArray(_data["selectedOptionIds"])) {
                this.selectedOptionIds = [] as any;
                for (let item of _data["selectedOptionIds"])
                    this.selectedOptionIds!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserMinigameResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserMinigameResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameId"] = this.minigameId;
        if (Array.isArray(this.selectedOptionIds)) {
            data["selectedOptionIds"] = [];
            for (let item of this.selectedOptionIds)
                data["selectedOptionIds"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUserMinigameResponseDto {
    minigameId?: number;
    selectedOptionIds?: number[] | undefined;
    id?: number;
}

export class UserParticipationGroupResponseDto implements IUserParticipationGroupResponseDto {
    groupId?: number;
    minigames?: UserMinigameResponseDto[] | undefined;
    id?: number;

    constructor(data?: IUserParticipationGroupResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["minigames"])) {
                this.minigames = [] as any;
                for (let item of _data["minigames"])
                    this.minigames!.push(UserMinigameResponseDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserParticipationGroupResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserParticipationGroupResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        if (Array.isArray(this.minigames)) {
            data["minigames"] = [];
            for (let item of this.minigames)
                data["minigames"].push(item ? item.toJSON() : <any>undefined);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUserParticipationGroupResponseDto {
    groupId?: number;
    minigames?: UserMinigameResponseDto[] | undefined;
    id?: number;
}

export class UserParticipationResponseDto implements IUserParticipationResponseDto {
    groups?: UserParticipationGroupResponseDto[] | undefined;
    id?: number;
    lastUpdate?: Date;
    usedBudget?: number;

    constructor(data?: IUserParticipationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(UserParticipationGroupResponseDto.fromJS(item));
            }
            this.id = _data["id"];
            this.lastUpdate = _data["lastUpdate"] ? new Date(_data["lastUpdate"].toString()) : <any>undefined;
            this.usedBudget = _data["usedBudget"];
        }
    }

    static fromJS(data: any): UserParticipationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserParticipationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item ? item.toJSON() : <any>undefined);
        }
        data["id"] = this.id;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>undefined;
        data["usedBudget"] = this.usedBudget;
        return data;
    }
}

export interface IUserParticipationResponseDto {
    groups?: UserParticipationGroupResponseDto[] | undefined;
    id?: number;
    lastUpdate?: Date;
    usedBudget?: number;
}

export class UserPlayGroupDto implements IUserPlayGroupDto {
    groupId?: number;
    minigames?: UserPlayMinigameDto[] | undefined;

    constructor(data?: IUserPlayGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["minigames"])) {
                this.minigames = [] as any;
                for (let item of _data["minigames"])
                    this.minigames!.push(UserPlayMinigameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserPlayGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPlayGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        if (Array.isArray(this.minigames)) {
            data["minigames"] = [];
            for (let item of this.minigames)
                data["minigames"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUserPlayGroupDto {
    groupId?: number;
    minigames?: UserPlayMinigameDto[] | undefined;
}

export class UserPlayMinigameDto implements IUserPlayMinigameDto {
    minigameId?: number;
    selectedOptionIds?: number[] | undefined;

    constructor(data?: IUserPlayMinigameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minigameId = _data["minigameId"];
            if (Array.isArray(_data["selectedOptionIds"])) {
                this.selectedOptionIds = [] as any;
                for (let item of _data["selectedOptionIds"])
                    this.selectedOptionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UserPlayMinigameDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPlayMinigameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minigameId"] = this.minigameId;
        if (Array.isArray(this.selectedOptionIds)) {
            data["selectedOptionIds"] = [];
            for (let item of this.selectedOptionIds)
                data["selectedOptionIds"].push(item);
        }
        return data;
    }
}

export interface IUserPlayMinigameDto {
    minigameId?: number;
    selectedOptionIds?: number[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}